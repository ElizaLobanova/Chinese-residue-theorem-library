\documentclass[10pt]{article}
\usepackage{femj_ru}
\usepackage{algorithm}
\usepackage{algorithmic}

%% Перед отправкой в журнал:
% 1. Перевести файл в кодировку windows-1251
% 2. в файле femj_ru.sty поменять \RequirePackage[utf8]{inputenc} на \RequirePackage[cp1251]{inputenc}
% 3. в файле femj_ru.sty удалить строку 10 \RequirePackage{soulutf8}

%Глубокоуважаемые авторы!

% прежде чем подключать дополнительные пакеты TeXa и создавать новые окружения, пожалуйста, ознакомьтесь с уже предусмотренными в стилевом файле журнала

% Используемые пакеты  перечислены в файле femj_ru.sty строки 7-30
% Обозначения окружений журнала и дополнительные команды приведены в стилевом файле femj_ru.sty строки 38-80

\begin{document}
\newcommand{\todo}[1]{\textbf{#1}}


\Pages(0--0)

\def\Im{\mathop{\mathrm{Im}}\nolimits}

\summary Trukhin~V.\,O.$^{1, 2}$\!, Strongin~V.\,S.$^{1, 2}$\!, Lobanova~E.\,A.$^{1, 2}$\, Anisich~A.\,I.$^{2}$\author

Application of the Chinese residue theorem for dealing with large numbers in supercomputing\title

In this paper we consider Something new and cool!
\keywords{Metropolis algorithm, statistical thermodynamics.}
\org{$^1$ Institute for Applied Mathematics, Far Eastern Branch, Russian Academy of Sciences\\ 
$^2$ Department of theoretical physics, Far eastern federal university, Russia}
\references{ %транслитерированный список литературы

\begin{thebibliography}{4}
\setlength{\parsep}{0pt}\setlength{\itemsep}{3pt}
\bibitem{hao2022cambricon}
\by Hao, Yifan and Zhao, Yongwei and Liu, Chenxiao and Du, Zidong and Cheng, Shuyao and Li, Xiaqing and Hu, Xing and Guo, Qi and Xu, Zhiwei and Chen, Tianshi
\jour 2022 55th IEEE/ACM International Symposium on Microarchitecture (MICRO)
\paper Cambricon-P: A bitflow architecture for arbitrary precision computing
\pages 57-72
\yr 2022

\bibitem{Okulov2011}
\by С. М. Окулов, А. В. Лялин
\jour Информатика и образование
\paper Расширенный алгоритм Евклида
\issue 5
\pages 37-41
\yr 2011

\bibitem{Cormen2001}
\by H. Cormen, E. Leiserson, L. Rivest, C. Stein
\jour The MIT Press 
\paper Introduction to Algorithms, Second Edition
\pages 950-954
\yr 2001


\bibitem{omondi2007residue}
\by Omondi, Amos R and Premkumar, A Benjamin
\jour Physics Letters A
\paper Residue number systems: theory and implementation
\vol 2
\yr 2007


\bibitem{soderstrand1986residue}
\by Soderstrand, Michael A and Jenkins, W Kenneth and Jullien, Graham A and Taylor, Fred J
\jour Physics Letters A
\paper Residue number system arithmetic: modern applications in digital signal processing
\yr 1986

\bibitem{shevchenko2017}
\by Y. Shevchenko, A. Makarov, K. Nefedev
\jour Physics Letters A
\paper Effect of long-and short-range interactions on the thermodynamics of dipolar spin ice
\vol 381
\issue 5
\pages 428-434
\yr 2017

\end{thebibliography}
}

\UDC{511.21+517.965+517.547.582}
\AMS{11B37 + 33E05}

\SupportedBy{Исследование выполнено за счет гранта Российского научного фонда № 24-71-10069, \linebreak https://rscf.ru/project/24-71-10069/\linebreak}

\submitted{ октября 2024 г.}

\title{Применение китайской теоремы об остатках для работы с большими числами в суперкомпьютерных вычислениях}

\author[1,2]{В.\, О.~Трухин}{Департамент теоретической физики и интеллектуальных технологий, Институт наукоемких технологий и передовых материалов, Дальневосточный федеральный университет. 690922, Россия, г. Владивосток, о. Русский, п. Аякс, 10}{trukhin.vo@dvfu.ru}
\author[1,2]{В.\, С.~Стронгин}{Институт прикладной математики, Дальневосточное отделение Российской академии наук. 690041, Россия, г. Владивосток, Ул. Радио д. 7}{}
\author[1,2]{Э.\, А.~Лобанова}{}{}
\author[1]{А.\, И.~Анисич}{}{anisich.ai@dvfu.ru}




\makeface

%\markright {Разбавленная модель кубического спинового льда ...} %Добавляем, если длинное название статьи
\markleft{В.\, О.~Трухин, В.\, С. Стронгин, Э.\,А.~Лобанова, ...} %добавляем, если много авторов


\abstract Задача ис \todo{Написать абстракт}

\keywords{алгоритмы, статистическая термодинамика.}

\DOI{to be presented}

\section*{Введение}

В ряде задач теоретической физики \cite{hao2022cambricon} данные представляются в виде чисел превышающих стандартные типы языков программирования ($\approx 2^{64}$). Традиционно эту проблема решается представлением чисел в виде строки произвольной длины (GNU Multi-Precision Library, Boost и др.). Однако такой подход замедляет расчёты, и не работает с графическими процессорами из-за их архитектуры.

В статье представлен алгоритм разложения больших чисел на остатки от деления на набор простых чисел, математические операции над полученными массивами и способ обратной сборки.

\section{Математическая модель} 

Алгоритм можно разбить на три этапа: 

\begin{enumerate}
	\item Разбиение большого числа на составные части (набор остатков)
	\item Математические операции с массивами остатков от деления на простые числа
	\item Расчёт результата из массива остатков от деления на простые числа
\end{enumerate}

Основой алгоритма является Китайская теорема об остатках (КТО) \cite{Okulov2011,Cormen2001}:

Пусть $a = a_1 a_2 ... a_k$, где $a_i$ попарно взаимно простые натуральные числа, $r = r_1 r_2 ... r_k$ -- натуральные числа удовлетворяющие неравенству $0 \leq r_i \le a_i$. Тогда найдётся такое число
$N$, для которого для всех $i$ выполняется:

\begin{equation}
	r_i=N \mod a_i
	\label{eq:rem_th}
\end{equation}

\section{Разбиение большого числа на составные части}

Из теоремы следует что, для того чтобы разложить число X на остатки $r_i$ необходимо найти остаток от деления на некоторый набор простых чисел $a_i$. Этот набор простых чисел определяет максимальное число $M$, которое мы сможем хранить с использованием КТО. $M$ задается формулой \ref{eq:corollary}

\begin{equation}
	M = \prod\limits_{i=1}^k a_i, ~~~ M \geqslant X
	\label{eq:corollary}
\end{equation}

Существует несколько подходов к выбору простых чисел для разбиения. Первый подход состоит в выборе минимального количества простых чисел, произведение которых превосходит $M$, и который помещаются в максимальный целочисленный тип данных, предоставляемый системой ($2^{32}$ или $2^{64}$). 
Второй подход предлагает использовать множество простых чисел, которые бы помещались в наиболее производительный тип данных. Для GPU таким является \textbf{int8}.
Несмотря на то, что для второго подхода необходимо производить больше операций за счёт большего количества чисел $a$, за счёт массового параллелизма этот подход даст больший прирост производительности.

\section{Математические операции с массивами остатков}

Определим операции сложения и вычитания для полученного набора остатков. Модульная арифметика \cite{omondi2007residue, soderstrand1986residue} определяет эти операции следующим образом: если два числа $X_1$ и $X_2$ представимы в виде систем остатков $(x_{11}, x_{12}, ..., x_{1n}) $ и $(x_{21}, x_{22}, ..., x_{2n})$ на модули $(p_1, p_2, ..., p_n)$, то 

\begin{align} 
	X_3 &= X_1 + X_2 = \nonumber \\ 
	& = ((r_{11} + r_{21})\ \mathrm{mod}\ a_1, (r_{12} + r_{22})\ \mathrm{mod}\ a_2, ..., (r_{1n} + r_{2n})\ \mathrm{mod}\ a_n), \\
	X_4 &= X_1 - X_2 = \nonumber \\ 
	& =((r_{11} - r_{21})\ \mathrm{mod}\ a_1, (r_{12} - r_{22})\ \mathrm{mod}\ a_2, ..., (r_{1n} - r_{2n})\ \mathrm{mod}\ a_n), \\
	X_5 &= X_1 \cdot X_2 = \nonumber \\ 
	& = ((r_{11} \cdot r_{21})\ \mathrm{mod}\ a_1, (r_{12} \cdot r_{22})\ \mathrm{mod}\ a_2, ..., (r_{1n} \cdot r_{2n})\ \mathrm{mod}\ a_n), 
\end{align}
т.е., чтобы сложить, вычесть или умножить 2 числа, достаточно сложить, вычесть или умножить соответствующие элементы векторов остатков этих двух чисел.

\section{Расшифровка числа из массива остатков}

Для расшифровки нужно найти модульно обратное $M_i^{-1}\equiv\frac{1}{M_i}\mod a_i$. Для поиска $M_i^{-1}$ используется расширенный алгоритм Евклида.
Расширенный алгоритм Евклида \cite{Okulov2011} является продолжением общего алгоритма Евклида. 

В общем алгоритме для чисел $a$ и $b$ рассчитываются частные $Q_{i-1}$ и остатки $R_i$ такие что $R_0 = a$, $R_1 = b$, $Q_{i-1} = \frac{R_{i-2}}{R_{i-1}}$ и $R_i = R_{i-2} - Q_{i-1} \cdot R_{i-1}$ до тех пор пока $R_i$ не станет равна нулю.

В расширенном алгоритме Евклида добавляются коэффициенты Безу $^1B_{i+1} = ^1B_{i-1} - ^1B_{i}$ и $^2B_{i+1} = ^2B_{i-1} - ^2B_{i}$. Первый коэффициент является модульно обратным для $M_i$ и $a$. Для поиска первого коэффициента был использован алгоритм (алг. \ref{algo:Evclid}).


\begin{algorithm}[H]
	\textbf{Ввод:} Два натуральных числа $a$ и $b$.\\
	\textbf{Вывод:} Первый коэффициент Безу $^1B$.
	\begin{algorithmic}
		\STATE {$R_0 = a$}
		\STATE {$R_1 = b$}
		\WHILE {$R_i > 0$}
			\STATE {$Q_{i-1} = \frac{R_{i-2}}{R_{i-1}}$}
			\STATE {$R_i = R_{i-2} - Q_{i-1} \cdot R_{i-1}$}
			\STATE {$^1B_{i+1} = ^1B_{i-1} - ^1B_{i}$}
		\ENDWHILE {}
		\STATE {$^1B = ^1B_{i+1}$}
	\end{algorithmic}
	\caption{Расширенный алгоритм Евклида}
	\label{algo:Evclid}
\end{algorithm}


Таким образом для того чтобы расшифровать число обратно используется следующий алгоритм:

\begin{algorithm}[H]
	\textbf{Ввод:} Массивы простых чисел $a[~]$, и остатков $r[~]$ длины $k$.\\
	\textbf{Вывод:} Расшифрованное число.
	\begin{algorithmic}
		\STATE {Рассчитать $M = \prod\limits_{i=1}^k a_i$}
		\STATE {Рассчитать $M_i = \frac{M}{a_i}$}
		\STATE {Используя расширенный алгоритм Евклида \cite{Okulov2011} найти первый коэффициент Безу $^1B$ для наибольшего общего делителя от $M_i$ и $a_i$:}
		\STATE {Рассчитать искомое число $x = (\sum\limits_{i=1}^{k} r_i \cdot M_i \cdot ^1B)\mod M$}
	\end{algorithmic}
	\caption{Расшифровка числа из простых чисел и остатков от делений на них.}
	\label{algo:crt_decription}
\end{algorithm}

В данном алгоритме для расшифровки числа необходимо вычислить произведение набора остатков на соответствующие $M_i$ и первый коэфициент Безу. Сумма данного произведения, взятая по модулю $M$, и будет равна исходному числу.


\section{Заключение}

Предлагаемый подход обладает рядом преимуществ, которые делают его эффективным для использования в вычислениях на GPU. Во-первых, параллелизация вычислений с использовнием алгоритма КТО делает вычисления независимыми благодаря работе с отдельными остатками. Это существенно ускоряет обработку массивов остатков на разных потоках или ядрах GPU.

Вторым преимуществом является уменьшение размера данных: представление больших чисел в виде остатков по модулям значительно снижает требования к объему памяти. Это особенно важно для GPU с ограниченными ресурсами памяти, что упрощает работу с большими числами. Третьим важным аспектом является избежание переполнения. Операции с большими числами могут столкнуться с переполнением, особенно при использовании 32- или 64-разрядных типов данных. Однако при разбиении числа на меньшие части по модулям, каждая из которых обрабатывается независимо, можно избежать проблемы переполнения в каждом модуле.

Кроме того, использование КТО способствует оптимизации памяти GPU. Модульное представление позволяет компактно размещать данные, что улучшает производительность ввода-вывода и снижает задержки доступа к памяти.

Несмотря на преимущества, подход с использованием КТО имеет ряд недостатков. Восстановление исходного числа после операций требует значительных ресурсов и может замедлить работу из-за синхронизации на GPU. Алгоритм с использованием КТО является избыточным при работе с числами, сопоставимым с простыми числами, используемыми для кодировки.

Таким образом алгоритм с использованием КТО является мощным инструментом для работы с большими числами на GPU. Его применение позволяет эффективно реализовывать параллелизацию, избежать переполнения и оптимизировать использование памяти. В задачах, требующих высокопроизводительных вычислений, таких как алгоритмы полного перебора и численные расчеты, КТО может существенно ускорить процесс обработки данных и повысить производительность системы.
%\vspace{15mm}

\begin{thebibliography}{20}
\setlength{\parsep}{0pt}\setlength{\itemsep}{3pt}


\bibitem{hao2022cambricon}
\by Hao, Yifan and Zhao, Yongwei and Liu, Chenxiao and Du, Zidong and Cheng, Shuyao and Li, Xiaqing and Hu, Xing and Guo, Qi and Xu, Zhiwei and Chen, Tianshi
\jour 2022 55th IEEE/ACM International Symposium on Microarchitecture (MICRO)
\paper Cambricon-P: A bitflow architecture for arbitrary precision computing
\pages 57-72
\yr 2022

\bibitem{Okulov2011}
\by С. М. Окулов, А. В. Лялин
\jour Информатика и образование
\paper Расширенный алгоритм Евклида
\issue 5
\pages 37-41
\yr 2011

\bibitem{Cormen2001}
\by H. Cormen, E. Leiserson, L. Rivest, C. Stein
\jour The MIT Press 
\paper Introduction to Algorithms, Second Edition
\pages 950-954
\yr 2001


\bibitem{omondi2007residue}
\by Omondi, Amos R and Premkumar, A Benjamin
\jour Physics Letters A
\paper Residue number systems: theory and implementation
\vol 2
\yr 2007


\bibitem{soderstrand1986residue}
\by Soderstrand, Michael A and Jenkins, W Kenneth and Jullien, Graham A and Taylor, Fred J
\jour Physics Letters A
\paper Residue number system arithmetic: modern applications in digital signal processing
\yr 1986

\bibitem{shevchenko2017}
\by Y. Shevchenko, A. Makarov, K. Nefedev
\jour Physics Letters A
\paper Effect of long-and short-range interactions on the thermodynamics of dipolar spin ice
\vol 381
\issue 5
\pages 428-434
\yr 2017

\end{thebibliography}



\EndArticle
\end{document} 