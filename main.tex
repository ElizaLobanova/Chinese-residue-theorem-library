\documentclass[10pt]{article}
\usepackage{femj_ru}
\usepackage{algorithm}
\usepackage{algorithmic}

%% Перед отправкой в журнал:
% 1. Перевести файл в кодировку windows-1251
% 2. в файле femj_ru.sty поменять \RequirePackage[utf8]{inputenc} на \RequirePackage[cp1251]{inputenc}
% 3. в файле femj_ru.sty удалить строку 10 \RequirePackage{soulutf8}

%Глубокоуважаемые авторы!

% прежде чем подключать дополнительные пакеты TeXa и создавать новые окружения, пожалуйста, ознакомьтесь с уже предусмотренными в стилевом файле журнала

% Используемые пакеты  перечислены в файле femj_ru.sty строки 7-30
% Обозначения окружений журнала и дополнительные команды приведены в стилевом файле femj_ru.sty строки 38-80

\begin{document}
\newcommand{\todo}[1]{\textbf{#1}}


\Pages(0--0)

\def\Im{\mathop{\mathrm{Im}}\nolimits}

\summary Trukhin~V.\,O.$^{1, 2}$\!, Strongin~V.\,S.$^{1, 2}$\!, Lobanova~E.\,A.$^{1, 2}$\, Anisich~A.\,I.$^{2}$\author

Application of the Chinese residue theorem for dealing with large numbers in supercomputing\title

In this paper we consider Something new and cool!
\keywords{Metropolis algorithm, statistical thermodynamics.}
\org{$^1$ Institute for Applied Mathematics, Far Eastern Branch, Russian Academy of Sciences\\ 
$^2$ Department of theoretical physics, Far eastern federal university, Russia}
\references{ %транслитерированный список литературы

\begin{thebibliography}{4}
\setlength{\parsep}{0pt}\setlength{\itemsep}{3pt}

\bibitem{Okulov2011}
\by С. М. Окулов, А. В. Лялин
\jour Информатика и образование
\paper Расширенный алгоритм Евклида
\issue 5
\pages 37-41
\yr 2011

\bibitem{Cormen2001}
\by H. Cormen, E. Leiserson, L. Rivest, C. Stein
\jour The MIT Press 
\paper Introduction to Algorithms, Second Edition
\pages 950-954
\yr 2001

\bibitem{shevchenko2017}
\by Y. Shevchenko, A. Makarov, K. Nefedev
\jour Physics Letters A
\paper Effect of long-and short-range interactions on the thermodynamics of dipolar spin ice
\vol 381
\issue 5
\pages 428-434
\yr 2017

\end{thebibliography}
}

\UDC{511.21+517.965+517.547.582}
\AMS{11B37 + 33E05}

\SupportedBy{Исследование выполнено за счет гранта Российского научного фонда № 24-71-10069, \linebreak https://rscf.ru/project/24-71-10069/\linebreak}

\submitted{ октября 2024 г.}

\title{Применение китайской теоремы об остатках для работы с большими числами в суперкомпьютерных вычислениях}

\author[1,2]{В.\, О.~Трухин}{Департамент теоретической физики и интеллектуальных технологий, Институт наукоемких технологий и передовых материалов, Дальневосточный федеральный университет. 690922, Россия, г. Владивосток, о. Русский, п. Аякс, 10}{trukhin.vo@dvfu.ru}
\author[1,2]{В.\, С.~Стронгин}{Институт прикладной математики, Дальневосточное отделение Российской академии наук. 690041, Россия, г. Владивосток, Ул. Радио д. 7}{}
\author[1,2]{Э.\, А.~Лобанова}{}{}
\author[1]{А.\, И.~Анисич}{}{anisich.ai@dvfu.ru}




\makeface

%\markright {Разбавленная модель кубического спинового льда ...} %Добавляем, если длинное название статьи
\markleft{В.\, О.~Трухин, В.\, С. Стронгин, Э.\,А.~Лобанова, ...} %добавляем, если много авторов


\abstract Задача ис \todo{Написать абстракт}

\keywords{алгоритмы, статистическая термодинамика.}

\DOI{to be presented}

\section*{Введение}

В ряде задач теоретической физики, аналитической биологии (?),.............. данные представляются в виде чисел превышающих стандартные типы языков программирования ($\approx 2^{64}$). Традиционно эту проблема решается представлением чисел в виде строки произвольной длины (GNU Multi-Precision Library, Boost и др.). Однако такой подход замедляет расчёты, и не работает с графическими процессорами из-за их архитектуры.

В статье представлен алгоритм разложения больших чисел на остатки от деления на набор простых чисел, математические операции над полученными массивами и способ обратной сборки.

\section{Математическая модель} 

Алгоритм можно разбить на три этапа: 

\begin{enumerate}
	\item Разбиение большого числа на составные части
	\item Расчёт результата из массива остатков от деления на простые числа
	\item Математические операции с массивами остатков от деления на простые числа
\end{enumerate}

Основой алгоритма является Китайская теорема об остатках (КТО) \cite{Cormen2001}:

Пусть $a = a_1 a_2 ... a_k$, где $a_i$ попарно взаимно простые натуральные числа, $r = r_1 r_2 ... r_k$ -- натуральные числа удовлетворяющие неравенству $0 \leq r_i \le a_i$. Тогда найдётся такое число
$N$, для которого для всех $i$ выполняется:

\begin{equation}
	N \mod a_i = r_i
	\label{eq:rem_th}
\end{equation}

Одно из следствий теоремы гласит что 

\section{Разбиение большого числа на составные части}

Из теоремы следует что, для того чтобы разложить число X на остатки $r_i$ необходимо найти остаток от деления на такой набор простых чисел $a_i$ чтобы:

\begin{equation}
	\prod\limits_{i=1}^k a_i \geqslant X
	\label{eq:collary}
\end{equation}
Для сохранения значения, например, $2^{20}$ в виде остатков можно было бы использовать два ближайших простых числа. Однако основной задачей является представление данных в формате, который оптимален для работы на конкретной архитектуре процессора. В связи с этим, для эффективного хранения следует выбирать ближайшие слева простые числа к значениям $2^{32}$ или $2^{64}$ в количестве $k$ необходимом, для соблюдения условия \ref{eq:collary} 

\section{Расшифровка числа из массива остатков}

Для расшифровки нужно найти модульно обратное $M_i^{-1}\equiv\frac{1}{M_i}\mod a_i$. Для поиска $M_i^{-1}$ используется расширенный алгоритм Евклида.
Расширенный алгоритм Евклида \cite{Okulov2011} является продолжением общего алгоритма Евклида. 

В общем алгоритме для чисел $a$ и $b$ рассчитываются частные $Q_{i-1}$ и остатки $R_i$ такие что $R_0 = a$, $R_1 = b$, $Q_{i-1} = \frac{R_{i-2}}{R_{i-1}}$ и $R_i = R_{i-2} - Q_{i-1} \cdot R_{i-1}$ до тех пор пока $R_i$ не станет равна нулю.

В расширенном алгоритме Евклида добавляются коэффициенты Безу $^1B_{i+1} = ^1B_{i-1} - ^1B_{i}$ и $^2B_{i+1} = ^2B_{i-1} - ^2B_{i}$. Первый коэффициент является модульно обратным для $M_i$ и $a$. Для поиска первого коэффициента был использован алгоритм (алг. \ref{algo:Evclid}).


\begin{algorithm}[H]
	\textbf{Ввод:} Два натуральных числа $a$ и $b$.\\
	\textbf{Вывод:} Первый коэффициент Безу $^1B$.
	\begin{algorithmic}
		\STATE {$R_0 = a$}
		\STATE {$R_1 = b$}
		\WHILE {$R_i > 0$}
			\STATE {$Q_{i-1} = \frac{R_{i-2}}{R_{i-1}}$}
			\STATE {$R_i = R_{i-2} - Q_{i-1} \cdot R_{i-1}$}
			\STATE {$^1B_{i+1} = ^1B_{i-1} - ^1B_{i}$}
		\ENDWHILE {}
		\STATE {$^1B = ^1B_{i+1}$}
	\end{algorithmic}
	\caption{Расширенный алгоритм Евклида}
	\label{algo:Evclid}
\end{algorithm}


Таким образом для того чтобы расшифровать число обратно используется следующий алгоритм:

\begin{algorithm}[H]
	\textbf{Ввод:} Массивы простых чисел $a[]$, и остатков $r[]$ длины $k$.\\
	\textbf{Вывод:} Расшифрованное число.
	\begin{algorithmic}
		\STATE {Рассчитать $M = \prod\limits_{i=1}^k a_i$}
		\STATE {Рассчитать $M_i = \frac{M}{a_i}$}
		\STATE {Используя расширенный алгоритм Евклида \cite{Okulov2011} найти первый коэффициент Безу $^1B$ для наибольшего общего делителя от $M_i$ и $a_i$:}
		\STATE{Рассчитать искомое число $x = \sum\limits_{i=1}^{k} r_i \cdot M_i \cdot ^1B$}
	\end{algorithmic}
	\caption{Расшифровка числа из простых чисел и остатков от делений на них.}
	\label{algo:crt_decription}
\end{algorithm}


\subsection{Математические операции с массивами остатков от деления на простые числа}

Определим операции сложения и вычитания для полученного набора остатков. Модульная арифметика \cite{omondi2007residue, soderstrand1986residue} определяет эти операции следующим образом: 

\todo{Написать операции + - *}

\section{Заключение}

Преимущества предлагаемого подхода:

\begin{itemize}
	\item \textbf{Параллелизация вычислений} 
	
	GPU предназначены для выполнения множества операций одновременно, и КТО идеально вписывается в эту модель, так как позволяет разбить большое число на набор меньших чисел, каждое из которых можно обрабатывать независимо. Это облегчает параллельную обработку остаточных систем на разных потоках или ядрах GPU, ускоряя вычисления.

	\item \textbf{Уменьшение размера данных}
	
	Большие числа можно представлять в виде набора меньших остатков по модулям, что существенно уменьшает размер данных для хранения. Это снижает потребности в памяти и упрощает работу с большими числами, поскольку GPU имеют ограниченные ресурсы памяти.

	\item \textbf{Избежание переполнения}
	
	Операции с большими числами на GPU могут столкнуться с проблемой переполнения, особенно в ограниченной памяти числовых типов, таких как 32- или 64-разрядные числа. Используя КТО, каждое число разбивается на более мелкие части, которые обрабатываются независимо, что позволяет избежать переполнения в рамках каждого модуля.

	\item \textbf{Ускорение атомарных арифметических операций}
	
	\todo{Написать про ускорение очереди атомарных операций}

	\item \textbf{Оптимизация использования памяти}
	
	Модульное представление позволяет эффективно использовать память GPU, так как каждый модуль обрабатывается отдельно и может быть размещен в более компактных структурах данных. Это улучшает производительность ввода-вывода и минимизирует задержки, связанные с доступом к памяти.

	
\end{itemize}

Недостатки:

\begin{itemize}
	\item  \textbf{Сложность обратного восстановления числа}
	После выполнения операций с числами, представленными в виде остатков по модулям, необходимо восстановить исходное число. Этот процесс, называемый восстановлением по Китайской теореме об остатках, может быть вычислительно сложным и требует дополнительных ресурсов. На GPU этот этап может оказаться узким местом из-за синхронизации и необходимости комбинирования данных.
	
	\item \textbf{Ограничение выбора модулей}
	Для эффективного применения КТО необходимо выбрать подходящие модули (числа, по которым берутся остатки), которые должны быть взаимно простыми (не иметь общих делителей, кроме единицы). Выбор таких модулей может быть сложным, особенно при работе с динамическими данными, где не всегда известно заранее, какие модули лучше использовать.
		
	\item \textbf{Неэффективность для малых чисел}
	КТО эффективна, когда необходимо обрабатывать очень большие числа, которые могут выходить за пределы стандартных типов данных. Однако для малых чисел сложность применения КТО может быть излишней, так как дополнительные операции с модулями и восстановление числа могут оказаться нецелесообразными с точки зрения вычислительных затрат.
	
	\item \textbf{Сложность реализации}
	Реализация вычислений по Китайской теореме об остатках на GPU требует тщательно продуманной архитектуры, которая может быть сложной в программировании. Это связано с необходимостью синхронизации потоков, оптимизации использования памяти и правильного выбора модулей. Ошибки в реализации могут привести к ухудшению производительности или к неверным результатам.
	
	\item \textbf{Увеличение числа операций}
	Хотя разбивка на более мелкие числа позволяет избежать переполнения, она увеличивает количество операций для каждого шага вычислений. Например, вместо одной операции умножения большого числа может потребоваться выполнение нескольких умножений и делений для остатков по каждому модулю. Это может компенсировать преимущества параллелизации в определенных сценариях.
	
	\item \textbf{Чувствительность к числу модулей}
	Для восстановления исходного числа нужно использовать достаточно большое количество модулей, чтобы покрыть весь диапазон исходного числа. Однако слишком большое количество модулей увеличивает объем вычислений и требований к памяти, что может негативно сказаться на производительности.
\end{itemize}

Несмотря на все недостатки, Китайская теорема об остатках остается мощным инструментом для работы с большими числами на GPU. Она позволяет эффективно использовать возможности параллелизации, уменьшает риск переполнения и оптимизирует использование памяти, что делает её особенно полезной в задачах, требующих высокопроизводительных вычислений, таких как криптография и численные расчеты. При правильной реализации и учете возможных трудностей, связанных с выбором модулей и восстановлением исходных данных, КТО может значительно ускорить обработку больших чисел и повысить общую производительность системы.
%\vspace{15mm}

\begin{thebibliography}{20}
\setlength{\parsep}{0pt}\setlength{\itemsep}{3pt}

\bibitem{Okulov2011}
	\by С. М. Окулов, А. В. Лялин
	\jour Информатика и образование
	\paper Расширенный алгоритм Евклида
	\issue 5
	\pages 37-41
	\yr 2011

\bibitem{Cormen2001}
\by H. Cormen, E. Leiserson, L. Rivest, C. Stein
\jour The MIT Press 
\paper Introduction to Algorithms, Second Edition
\pages 950-954
\yr 2001


\bibitem{omondi2007residue}
\by Omondi, Amos R and Premkumar, A Benjamin
\jour Physics Letters A
\paper Residue number systems: theory and implementation
\vol 2
\yr 2007


\bibitem{soderstrand1986residue}
\by Soderstrand, Michael A and Jenkins, W Kenneth and Jullien, Graham A and Taylor, Fred J
\jour Physics Letters A
\paper Residue number system arithmetic: modern applications in digital signal processing
\yr 1986

\bibitem{shevchenko2017}
\by Y. Shevchenko, A. Makarov, K. Nefedev
\jour Physics Letters A
\paper Effect of long-and short-range interactions on the thermodynamics of dipolar spin ice
\vol 381
\issue 5
\pages 428-434
\yr 2017

\end{thebibliography}



\EndArticle
\end{document} 